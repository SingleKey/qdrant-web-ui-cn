export const title = '全文过滤';

# 全文过滤

这是一个关于**Qdrant中的全文过滤**的分步教程，使用带有描述字段的行星数据集合：

## 步骤1：创建集合

我们首先创建一个名为`star_charts`的集合，向量大小为4，相似度距离度量设置为点积。

```json withRunButton="true"
PUT /collections/star_charts
{
  "vectors": {
    "size": 4,
    "distance": "Dot"
  }
}
```

## 步骤2：在负载中添加带有描述的数据

接下来，我们向集合中添加数据。每个条目包含一个id、向量和一个负载，负载包含各种天体的详细信息，如殖民地信息、是否支持生命以及描述。

```json withRunButton="true"
PUT collections/star_charts/points
{
  "points": [
    {
      "id": 1,
      "vector": [0.05, 0.61, 0.76, 0.74],
      "payload": {
        "colony": "Mars",
        "supports_life": true,
        "description": "The red planet, Mars, has a cold desert climate and may have once had conditions suitable for life."
      }
    },
    {
      "id": 2,
      "vector": [0.19, 0.81, 0.75, 0.11],
      "payload": {
        "colony": "Jupiter",
        "supports_life": false,
        "description": "Jupiter is the largest planet in the solar system, known for its Great Red Spot and hostile gas environment."
      }
    },
    {
      "id": 3,
      "vector": [0.36, 0.55, 0.47, 0.94],
      "payload": {
        "colony": "Venus",
        "supports_life": false,
        "description": "Venus, Earth’s twin in size, has an extremely thick atmosphere and surface temperatures hot enough to melt lead."
      }
    },
    {
      "id": 4,
      "vector": [0.18, 0.01, 0.85, 0.80],
      "payload": {
        "colony": "Moon",
        "supports_life": true,
        "description": "Earth’s Moon, long visited by astronauts, is a barren, airless world but could host colonies in its underground caves."
      }
    },
    {
      "id": 5,
      "vector": [0.24, 0.18, 0.22, 0.44],
      "payload": {
        "colony": "Pluto",
        "supports_life": false,
        "description": "Once considered the ninth planet, Pluto is a small icy world at the edge of the solar system."
      }
    }
  ]
}
```

### 步骤3：尝试使用精确短语过滤（子字符串匹配）

现在，让我们尝试过滤描述以查找包含精确短语"host colonies"的条目。
Qdrant默认支持使用精确匹配进行文本过滤，但请注意这不会对文本进行分词。

```json withRunButton="true"
POST /collections/star_charts/points/scroll
{
  "filter": {
    "must": [
      {
        "key": "description",
        "match": {
          "text": "host colonies"
        }
      }
    ]
  },
  "limit": 2,
  "with_payload": true
}
```

您会注意到这个过滤器有效，但如果您稍微更改短语，它将不会返回结果，因为未索引文本中的子字符串匹配对于变体不够灵活。

**注意**：如果您的集群运行在Qdrant Cloud上，此查询将失败。在Qdrant Cloud上，集合默认配置为在严格模式下运行，这会阻止查询未索引的字段。您将在下一步学习如何为文本过滤索引字段。

### 步骤4：索引描述字段

为了使过滤更强大和灵活，我们将索引`description`字段。这将分词文本，允许更复杂的查询，例如过滤像"cave colonies"这样的短语。我们使用`word`分词器，只有长度在5到20个字符之间的标记才会被索引。

**注意：** 您应该始终在过滤之前索引字段。如果您在创建索引之前使用过滤（如步骤3），Qdrant将以非结构化方式搜索整个数据集。您的搜索性能将非常慢。

```json withRunButton="true"
PUT /collections/star_charts/index
{
    "field_name": "description",
    "field_schema": {
        "type": "text",
        "tokenizer": "word",
        "lowercase": true
    }
}
```

### 步骤5：再次尝试过滤器

索引后，您现在可以再次运行过滤器，但这次不是搜索短语。
现在您将过滤描述中的所有标记"caves"和"colonies"。 

```json withRunButton="true"
POST /collections/star_charts/points/scroll
{
  "filter": {
    "must": [
      {
        "key": "description",
        "match": {
          "text": "caves colonies"
        }
      }
    ]
  },
  "limit": 2,
  "with_payload": true
}
```
## 总结

在未索引字段上进行全文过滤默认执行子字符串匹配，或者在严格模式下运行的集合上导致错误（Qdrant Cloud上的默认设置）。最佳实践是首先索引字段。这使得更高级的全文查询成为可能，例如完全忽略单词顺序的查询。