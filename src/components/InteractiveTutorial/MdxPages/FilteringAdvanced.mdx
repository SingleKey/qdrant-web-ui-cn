export const title = "高级过滤"

# 高级过滤 - 嵌套过滤器

## 步骤1：创建集合

首先创建一个名为`dinosaurs`的集合，向量大小为4，距离度量设置为`Dot`：

```json withRunButton="true"
PUT collections/dinosaurs
{
  "vectors": {
    "size": 4,
    "distance": "Dot"
  }
}
```

## 步骤2：添加带有负载的向量

现在可以向集合中添加点。每个点包含一个`id`、`vector`和一个带有附加信息的`payload`，例如恐龙物种和饮食偏好：

```json withRunButton="true"
PUT collections/dinosaurs/points
{
  "points": [
    {
      "id": 1,
      "vector": [0.1, 0.2, 0.3, 0.4],
      "payload": {
        "dinosaur": "t-rex",
        "diet": [
          { "food": "leaves", "likes": false },
          { "food": "meat", "likes": true }
        ]
      }
    },
    {
      "id": 2,
      "vector": [0.2, 0.3, 0.4, 0.5],
      "payload": {
        "dinosaur": "diplodocus",
        "diet": [
          { "food": "leaves", "likes": true },
          { "food": "meat", "likes": false }
        ]
      }
    }
  ]
}
```


## 步骤3：在过滤前索引字段

**注意：** 您应该始终在过滤之前索引字段。如果在创建索引之前使用过滤，Qdrant将以非结构化方式搜索整个数据集。您的搜索性能将非常慢。

```json withRunButton="true"
PUT /collections/dinosaurs/index
{
    "field_name": "diet[].food",
    "field_schema": "keyword"
}
```

```json withRunButton="true"
PUT /collections/dinosaurs/index
{
    "field_name": "diet[].likes",
    "field_schema": "bool"
}
```

## 步骤4：使用`match`进行基本过滤

您可以通过特定的负载值过滤点。例如，下面的查询匹配以下条件的点：

- `diet[].food`包含"meat"
- `diet[].likes`设置为`true`

两个点都匹配这些条件，因为：
- "t-rex"吃肉并且喜欢它
- "diplodocus"吃肉但不喜欢它

```json withRunButton="true"
POST /collections/dinosaurs/points/scroll
{
  "filter": {
    "must": [
      {
        "key": "diet[].food",
        "match": {
          "value": "meat"
        }
      },
      {
        "key": "diet[].likes",
        "match": {
          "value": true
        }
      }
    ]
  }
}
```

但是，如果您只想检索数组中同一元素同时满足两个条件的点（例如，ID为1的"t-rex"），则需要使用**嵌套过滤器**。

## 步骤5：使用嵌套对象过滤器进行高级过滤

要在数组元素级别应用过滤器，您需要使用`nested`过滤器条件。这确保`food`和`likes`值在每个数组元素内一起评估：

```json withRunButton="true"
POST /collections/dinosaurs/points/scroll
{
  "filter": {
    "must": [
      {
        "nested": {
          "key": "diet",
          "filter": {
            "must": [
              {
                "key": "food",
                "match": {
                  "value": "meat"
                }
              },
              {
                "key": "likes",
                "match": {
                  "value": true
                }
              }
            ]
          }
        }
      }
    ]
  }
}
```

使用此过滤器，只有"t-rex"（ID 1）被返回，因为它的数组元素满足两个条件。

### 解释

嵌套过滤器将每个数组元素视为独立的对象，将过滤器独立应用于每个元素。如果任何一个数组元素满足所有条件，则父文档（在本例中为恐龙点）匹配过滤器。

## 步骤6：将`has_id`与嵌套过滤器结合使用

请注意，`has_id`不能在嵌套过滤器内部使用。如果您还需要按ID过滤，请将`has_id`条件作为单独的子句包含，如下所示：

您不会得到不同的答案。您可以看到此过滤器通过将`nested`饮食过滤器与显式ID匹配相结合来匹配"t-rex"（ID 1）。

```json withRunButton="true"
POST /collections/dinosaurs/points/scroll
{
  "filter": {
    "must": [
      {
        "nested": {
          "key": "diet",
          "filter": {
            "must": [
              {
                "key": "food",
                "match": {
                  "value": "meat"
                }
              },
              {
                "key": "likes",
                "match": {
                  "value": true
                }
              }
            ]
          }
        }
      },
      {
        "has_id": [1]
      }
    ]
  }
}
```

